# 4 スキーマとデータ型の最適化

本章ではMySQLのスキーマの設計について説明する。
主にはMySQL データベースの設計に特化した内容になっている。

# 4.1 最適なデータ型の選択

データの型を決めるときには下記を基準に考えるのがよい

###  通常は小さいほうがよい

>データの格納と表現を正しく行うことができるデータ方のうち、最も小さいものを使用するのが良い。
データ型が小さいとディスク、メモリ、CPUキャッシュで使用する領域が少なくなるため通常はそのほうが高速。 
最適なデータ型で迷っている場合は、範囲を超えそうにないデータ型のうち最も小さいものを選択する。

### 単純なものがよい

>データ型が単純であるほど、その操作を処理するのに必要な CPU サイクルは一般に少なくなる。
並び順を格納するのに文字列（a,b,c,,,）を使用するより整数を使用したほうが比較するコストも少なくすむ。
日付と時刻は文字列ではなくDate型を格納すべきでありIPアドレスには整数型を使用すべきである。

### できる限りNULLを使用しない

>多くのテーブルには、アプリケーションが NULL を格納する必要がない場合でも、それがデフォルトであるという理由だけで NULL 値を設定できる列が含まれている。
NULLを格納する予定がなければNOT NULLを指定すべき。
NULL 値を設定できる列はインデックスやインデックス統計、値の比較を複雑にするため、それらを参照するクエリを MySQL で最適化するのは難しい。NULL 値を設定できる列により、より多くの記憶域が使用され、MySQL 内で特殊な処理が必要となる。
通常、NULL 列を NOT NULL に変更した場合のパフォーマンスの向上はわずかである。
既存のスキーマでNOT NULLに変更を優先しておこなわなくても良いが、列にインデックスを付けることを計画している場合は、NULL 値を設定できる列にするのはなるべく避けるようにする。

次にMySQLで使用できる基本的なデータ型について説明。

## 4.1.1 整数型

整数を格納する場合は下記５つあり、それぞれ`UNSIGNED`属性をもたせると整数のみとなり正の数の上限が約２倍になる。

### TINYINT
符号あり：-128 ~ 127
符号なし：0 ~ 255

### SMALLINT
符号あり：-32768 ~ 32767
符号なし：0 ~ 65535

### MEDIUMINT
符号あり：-8388608 ~ 8388607
符号なし：0 ~ 16777215

### INT
符号あり：-2147483648 ~ 2147483647
符号なし：0 ~ 4294967295

### BIGINT
符号あり：-9223372036854775808 ~ 9223372036854775807 
符号なし：0 ~ 18446744073709551615 

## 4.1.2 実数型

実数とは小数部を持つ数字である。
例外としてBIGINT に収まらない大きな整数を格納するために DECIMAL を使用することもできる。
DECIMAL 型は記憶域と計算上のコストが増えるため少数部分の正確な結果が必要な場合やBIGINT型で収まらないとき以外はは基本的に使用しない。

### FLOAT
-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807

### DOUBLE
-3.402823466E+38 ~ 3.402823466E+38

### DECIMAL
-2.2250738585072014E-308 ~  2.2250738585072014E-308

## 4.1.3 文字列型

MySQL がサポートしている文字列データ型はさまざまであり、それぞれいくつかの種類に分かれている。

###  VARCHAR 型と CHAR 型

主な文字列型は、文字値を格納する VARCHAR と CHAR の 2 つである。

***VARCHAR***

可変長の文字列を格納する最も一般的な文字列型。
VARCHAR は値の長さを記録するため列の最大長が255 バイト以下である場合は 1 バイトを使用し、それよりも大きい場合は 2 バイトを余分に使用する。

指定できる文字数：0 ~ 65535

***CHAR***

固定長の文字列型。
CHAR 型の値を格納する際、MySQL は末尾のスペースをすべて削除する。
そのため、CHAR は値を格納されると、指定された長さになるように右側がスペースで埋められます。

CHAR は、非常に短い文字列を格納したい場合、またはすべての値がほぼ同じ長さである場合に役立つ。

列が非常に短い場合も、VARCHAR よりも効率的である。
たとえば、Y 値と N 値を保持するように設計された CHAR(1) は 1 バイトの文字セットで 1 バイトしか使用しないが † 、VARCHAR(1) は長さバイトの分も合わせて 2 バイトを使用する。

指定できる文字数：0~255

###  BLOB 型と TEXT 型

BLOB と TEXT はそれぞれバイナリまたは文字列として大量のデータを格納するために設計された文字列型である。

BLOB 型はバイナリデータを称号順序や文字セットなしで格納する。
TEXT型は文字セット（文字数）と照合順序（並び替えルール）を格納する。
> 照合順序：大文字と小文字を区別するかどうかやバイナリで比較するかどうかなどを指定できる。

***TEXT***

格納できる数：65,535バイト]

***BLOB***

格納できる数：65,535バイト

### 文字列の変わりにENUMを使用する

場合によっては、従来の文字列型の代わりに ENUM 型の列を使用できることがある。
ENUM 型の列には事前に定義された文字列値を格納できる。

```
-- create table
create table strtest(product varchar(8), num1 enum('Blue', 'Yellow', 'White'));

-- insert 次のように追加できる
insert into strtest values('Desk', 'Blue');
insert into strtest values('Mouse', 'White');

-- inser 下記の場合はエラー
insert into strtest values('PC', 'Green');

-- select
select * from strtest;
+---------------+-------------+
| product         | num1         |
+---------------+-------------+
|  Desk            | Blue          | 
| Mouse          | White        |
+---------------+-------------+

```

ENUM 型を使うとカラムに格納することができる値を簡単に制限することができます。


|  テスト |   1 秒あたりのクエリの数 |
|---|---|
|  VARCHAR と VARCHAR の結合  | 2.6 |
|   VARCHAR と ENUM の結合 | 1.7 |
|  ENUM と VARCHAR の結合 | 1.8 |
|  ENUM と ENUM の結合 | 3.5 |

上記の表の通り、VARCHAR 列と ENUM 列の結合は高速になるため、文字同士で結合するときに使用するとパフォーマンスに良い。

## 4.1.4 日付と時刻型

MySQL が格納できる時間の精度は 1 秒までである。
MySQLではDATETIMEとTIMESTAMPがある。

### DATETIME
1001 ～ 9999 年までの値を格納することが可能で、精度は 1 秒。
デフォルトでは、MySQL は DATETIME 型の値を 2008-01-16 22:37:08 のようにソート可能な明確な書式で表示する。
データの格納には8 バイトの記憶域が使用される。

### TIMESTAMP

記憶域を 4 バイトしか使用しないため、DATETIME 型よりも範囲がずっと狭い（1970 年からら 2038 年の途中まで）。
デフォルトでは、列の値を指定せずに行を挿入すると、MySQL は最初の TIMESTAMP 型の列に現在の時刻を設定する。
また、UPDATE 文で値を明示的に割り当てない限り、MySQL はデフォルトで最初の TIMESTAMP型の列の値を更新する。


IMESTAMP は DATETIME よ り も ス ト レ ー ジ 効 率 が よ い た め、TIMESTAMP を使用できる場合は一般にこちらを使用すべきである。

## 4.1.5 ビットデータ型

MySQL には、値の個々のビットを使ってデータをコンパクトに格納する格納型がいくつかある。
これらの型はすべて、元の格納形式や操作に関係なく、技術的には文字列型である。

### BIT

BIT 型の列を使用すれば、1 つ以上の真偽値を 1 つの列に格納できる。
1つの列に格納できる。BIT(1) は 1 ビットを格納するフィールドを定義し、BIT(2) は 2 ビットを格納するフィールドを定義する。
BIT型の最大の長さは 64 ビットである。

この型はMemory や InnoDBではビットを保持するのに整数型の最小の型として列に格納するため記憶域の節約にならない。
また、０や１を格納する場合バイナリ値の０や１を格納するため比較をする際は注意が必要。
基本的にはこの型を使用しないほうが良い。

### SET

多くの真偽値を格納する必要がある場合は,この型を使って複数の列を１つにまとめるビットの集合として表すことが可能。
SET はストレージ効率がよく、MySQL には FIND_IN_SET()や FIELD() といったクエリに使用しやすい関数がある。

```sql
mysql> CREATE TABLE myset (col SET('a', 'b', 'c', 'd'));

mysql> INSERT INTO myset (col) VALUES 
    -> ('a,d'), ('d,a'), ('a,d,a'), ('a,d,d'), ('d,a,d');

mysql> SELECT col FROM myset;
+------+
| col    |
+------+
| a,d    |
| a,d    |
| a,d    |
| a,d    |
| a,d    |
+------+
```
SETサポートされていない値を列に 設定すると、その値は無視され、警告が発行されます。

## 4.1.6 ID列の選択肢

ID列のデータ型の選択は非常に重要。
他の列に比べて、結合などで他の値と比較したり、条件に使用したりすることが多い。
また、他のテーブルで外部キーとして使用する可能性も高いため、ID列のデータ型を選択した際には、関連先のテーブルでもそのデータ型を選択することになる。
型を選択した後は、すべての関連テーブルで同じ型を使用するようにしよう。UNSIGNED などの特性を含め、型は正確に一致しなければならない 。異なるデータ型を組み合わせると、パフォーマンスが低下する可能性がある。

### 整数型
整数は素早く処理され、AUTO_INCREMENTに対応するため、通常は整数型を選択する。

### ENUM とSET
一般にこれらの方はIDにふさわしくないが、状態や種類を含んでいる定義テーブルには適していることがある。
ENUM 型と SET 型の列は、注文状況、製品の種類、性別などの情報を格納するのに適している。
ENUM フィールドを使って製品の種類を定義する場合は、まったく同じ ENUMフィールドを主キーとするルックアップテーブルが必要になるかもしれない。
この場合は、ENUMを ID として使用するが、ほとんどの目的ではそうすることを避けるべきである。

### 文字列型
文字列型は記憶域を大量に消費し、一般に整数型よりも低速なので、なるべく ID には使用しない。

## 4.1.7 特殊なデータ型

システムで利用可能な組み込み型に直接対応しないデータがある。
精度が秒以下のタイムスタンプやIP アドレスである。
よくあるのは、IPアドレスはVARCHAR(15) 型の列を使って IP アドレスを格納する。しかし、IPアドレスは符号なし32ビット整数である。
ドットは人が読みやすいように区切られているだけである。そのためIPアドレスは符号なし整数として格納すべきである。
MySQL には、この 2 つの表現を変換するための INET_ATON() 関数と INET_NTOA() 関数がある。

> INET_ATON() : IPアドレスを数値で返す

>INET_ATONA(): 	数値から IP アドレスを返します


# 4.2 MySQLでのスキーマの設計

スキーマの設計でMySQLでしか発生しない問題を紹介。

## 列の数が多すぎる

MySQLのストレージエンジンAPIは、サーバーとストレージエンジンの間で行を行バッファ形式でコピーする。
その後、サーバーはコピーされた行バッファを列にデコードする。
その後のデコードされた列から行データ構造にする作業にはコストがかかる可能性がある。
この変換のコストは列の数に依存する。

## 結合の数が多すぎる
アンチパターンであるEAV（Entity-Attribute-Value）デザインパターンを使用すると陥る。
EAV（Entity-Attribute-Value）デザインパターンは、どのデータベースでも例外なく悪いデザインパターンの代表格だが、MySQL では特にうまくいかない。
MySQL では、1 つの結合に使用できるテーブルの数が 61 に制限されているが、EAV データベースでは多くの自己結合が必要となる ため、61を上回る。
ただし、61を下回っていたとしてもクエリプランと最適化のコストがMySQL に重くのしかかることがある。
だいたいの目安として、並行性の高い環境でクエリを高速に実行する必要がある場合は、1 つのクエリで使用するテーブルの数を 10 個かそれ以下にしたほうがよい。

***EAV例***
テーブル構造
![image2](/image/image2.jpg)

データ
```
mysql > select * from Issue;
+------------+
| issue_id    |
+------------+
| 123           |
+------------+

mysql > select * from IssueAttribute;
+------------+------------------+------------------+
| issue_id    | attr_name        | attr_value         |
+------------+------------------+------------------+
| 123           | product            | 1                       |
+------------+------------------+------------------+
| 123           | date_reported | 2009-06-01        |
+------------+------------------+------------------+
| 123           | status               | NEW                |
+------------+------------------+------------------+
| 123           | description       | 保存処理        |
+------------+------------------+------------------+
| 123           | reported_by     | Bill                   |
+------------+------------------+------------------+
```

上記から行で取得するときに結合をしないと取得ができないため最大で結合が`attr_name`に格納されている重複を省いた値の数行わないといけなくなる。
```sql
SELECT i.issue_id,
    i1.attr_value AS date_reported,
    i2.attr_value AS status,
    i3.attr_value AS reported_by,
    i4.attr_value AS description
FROM Issue AS i
    LEFT OUTER JOIN IssueAttribute AS i1
        ON i.issue_id = i1.issue_id AND i1.attr_name = 'date_reported'
    LEFT OUTER JOIN IssueAttribute AS i2
        ON i.issue_id = i2.issue_id AND i2.attr_name = 'status'
    LEFT OUTER JOIN IssueAttribute AS i3
        ON i.issue_id = i3.issue_id AND i3.attr_name = 'reported_by'
     LEFT OUTER JOIN IssueAttribute AS i4
        ON i.issue_id = i4.issue_id AND i4.attr_name = 'description'
WHERE i.issue_id = 1234;
```

## 何でもありのENUM

ENUMを何にでも使用するのは良くない。
下記の例の場合、実際には「ディクショナリ」か「ルックアップテーブル」への外部キーとなる整数値のはず。
しかし`country`に新しく行を追加したいとなった場合、ALTER TABLEを使用しないと32個目以上に追加ができないため、拡張性にかけてしまう。

``` sql
CREATE TABLE ... (
    country enum(' ', '0', '1', '2', .......'31')
```
## もう 1 つの ENUM

ENUとSETを適切に使う。

ENUM 型の列を使用すれば、定義済みの値の中からどれか 1 つを格納できる。
SET 型の列を使用すれば、定義済みの値の中から 1 つ以上の値を格納できる。

下記の例の場合、仮に入る値が`true`か`false`どちらかしか入らない場合は`ENUM`を使用すべきだとわかる。
```sql
CREATE TABLE ...(
    is_default set('Y','N') NOT NULL default 'N'
```

## 別の NULL を作らない
`NULL`を使用はなるべく避けたほうが良い。その代替として代わりに 0 を使用するか、特別な値を使用するか、空の文字列を使用すればよい。
しかし何にでも`NULL`の代わりを使用すれば良いということではなく`-1`をデフォルトにすることでコードがかなり複雑になったりバグが発生しやすくなるなら`NULL`を選択したほうが良い。


# 4.3 正規化と非正規化

- 正規化
    - 正規化されたデータベースでは、重複した情報が存在しない。
- 非正規化
    - 非正規化されたデータベースでは情報が重複して存在している。

それぞれのテーブルの例
```
非正規化

テーブル名：employ
|  employe_id | employe_name | department  |
----------------+-------------------+----------------
|   1                |  Jones        　　| Accounting  |
|   2                |  Smith       　　| Engineering  |
|   3                |  Brown      　　| Accounting  |
-------------------------------------------------------

正規化

テーブル名：employe
|  employe_id | employe_name | department_id  |
---------------+-------------------+---------------------
|   1               |  Jones        　　| 1                         |
|   2               |  Smith       　　| 2                         |
|   3               |  Brown      　　| 1                         |
-----------------------------------------------------------

テーブル名：department
|  department_id | department _name |
-------------------+------------------------+
|   1                    | Accounting             |
|   2                    | Engineering            |
----------------------------------------------

```

非正規化の問題点は、データの変更が容易ではないこと。
例えば部門の名称を変更する場合、該当の社員の`department`の内容を全て変更をしなければ行けない。
正規化をしている場合は`department`テーブルの該当の`department _name `の一箇所のレコードを変更すれば済む。

## 4.3.1 正規化されたスキーマの長所と短所

パフォーマンスの問題を解決したい時、特に処理の大半が書き込みである場合は正規化が下記の有効となる。

書き込みにより理由
- 正規化された更新は非正規化された更新よりも通常は高速である。
- データがうまく正規化されていれば、データの重複がほとんどあるいはまったくないため、変更するデータが少なくなる。
- 通常は正規化されたテーブルのほうが小さいため、メモリ内にうまく収まり、パフォーマンスもよくなる。
- 冗長データがないということは、値のリストを取得するときに DISTINCT クエリや GROUPBY クエリを実行する必要があまりないということである。

4つ目は先程のテーブルで考えるとわかりやすい。
例えば部署を重複なく取得した場合、非正規化だと`GROUP　BY`等で取得が必要になるが、正規化の場合`department`テーブルを取得するだけで済む。

正規化されているスキーマの欠点は取得時にある。
データの取得をする際に結合を１つ以上する必要がほとんどになる。
結合は基本コストがかかるだけではなく、一部のインデックス戦略を不可能にすることもある。
例えば、同じインデックスに属していることにメリットがあった列が、正規化によって別のテーブルに配置されてしまうかもしれない。

## 4.3.2 非正規化されたスキーマの長所と短所

非正規化されたスキーマのメリットは下記３つとなる。
- すべてが同じテーブルに含まれていて、結合が不要になること。
- フルテーブルスキャンは、結合よりもはるかにパフォーマンスがよい可能性がある。
- テーブルが 1 つの場合は、より効率的なインデックス戦略も可能となる。
> フルテーブルスキャンテーブルのレコードを全て検索すること

インデックス戦略の例として、下記の正規化されたテーブルを結合するクエリがあるとする。
※インデックスが何かは次の章で説明しているので、ここでは早くなるためにインデックスを付与したカラム順にデータを保持していると考えてもらうと良いかと思います。

```sql
mysql> SELECT message_text, user_name
            -> FROM message
            ->      INNER JOIN user ON message.user_id=user.id
            -> WHERE user.account_type='premiumv
            -> ORDER BY message.published DESC LIMIT 10;
```
上記はユーザーがメッセージを投稿する Web サイトがあり、一部のユーザーがプレミアムユーザーとする。
そのwebサイトで プレミアムユーザーが最近投稿したメッセージを 10 件抽出したいときのクエリ。また、メッセージの投稿日（published）にインデックスを付けている。

上記クエリを実行した場合、データの抽出までの検索は下記となる。
1. message テーブルで published インデックスをスキャン
2. 検出された行ごとに、user テーブルを調べてそのユーザーがプレミアムユーザーかどうかを確認

10件のデータがpublishedの降順で先の方にあれば高速だが最後の1件目にあった場合に非効率となる。
非効率となる問題は1 つのインデックスでソートとフィルタリングを同時に行うことができないことにある。

テーブルを非正規化することにし、テーブルを組み合わせて (account_type,published) にインデックスを追加すれば、結合なしでクエリを記述できるようになる。

```sql
mysql> SELECT message_text,user_name
             -> FROM user_messages
            -> WHERE account_type='premium'
            -> ORDER BY published DESC
            -> LIMIT 10;
```
上記の場合は、message テーブルで account_type,publishedインデックスをスキャンして`account_type`が`premium`になっているデータの最新の投稿日から10件取得するだけで済むため、最大10件の検索で済むことになる。

### 4.3.3 正規化と非正規化の混合

実際にはどちらかだけを使用することよりも、正規化されたスキーマ、キャッシュテーブル、およびその他の方法を使用するなどして、2 つの手法を組み合わせなければならないケースが大半を占めている。

先の Web サイトの例では、完全に非正規化する代わりに、account_type を user テーブルと message テーブルの両方に格納することができる。そうすれば、メッセージが存在しない場合でもユーザーに関する情報は失われないため、完全な非正規化に伴う挿入と削除の問題が解消される。

一方で両方のテーブル変更が必要になるため、更新には手間がかかるようになる。それば問題なのかは`SELECT`を実行する頻度と`UPDATE`を実行する頻度を照らし合わせてどちらの時間を優先するかで決定するのが良い。

