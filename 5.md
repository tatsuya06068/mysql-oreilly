# 5章 インデックスによるパフォーマンスの向上

インデックスは、ストレージエンジンが行を素早く検索するために使用するデータ構造のこと。
インデックスはパフォーマンスを向上させるのに欠かせない存在となる。
データセットが大きいほどインデックスの効果は大きくなる。


- 5.1 インデックスの基礎
- 5.2 インデックスの利点
- 5.3 ハイパフォーマンスを可能にするインデックス戦略
- 5.4 インデックスのケーススタディ
- 5.5 インデックスとテーブルの管理
- 5.6 まとめ


# 5.1インデックスの基礎
インデックスは本の索引に置き換えるとわかりやすい。
特定の項目が本のどこに乗っているのかを確認するために索引を調べれば、その項目登場するベージ番号がわかる。

MySQL のストレージエンジンでも、インデックスが同じような方法で使用されている。
下記のクエリを例にした場合、で考える。
```
mysql> SELECT ﬁrst_name FROM sakila.actor WHERE actor_id = 5;
```
`actor_id`列にインデックスを振られている場合、Mysqlでは`actor_id`5の箇所をインデックスを見て検索して行の取得をする。

```
actor_id
1 ・・・ 5行目
2 ・・・ 8行目
3 ・・・ 3行目
4 ・・・ 10行目
5 ・・・ 40行目
```

インデックスには一つだけではなく複数の指定ができる。(例：IDとNameにインデックスを付与)

## 5.1.1 インデックスの種類

インデックスは様々な種類があり、目的に合わせて設計されている。
インデックスはサーバー層ではなくストレージエンジン層で実装されているため、データベースエンジンごとに動作がことなります。

MySQLがサポートしているインデックスの種類について説明します。
※B木インデックスが基本的に使用されるため他のインデックスは簡単な説明にします。

### B木インデックス

インデックスと言われたら基本的にはB木インデックスのことを指しています。

MySQLのストレージエンジンのほとんどは、この種類のインデックスをサポートしている。Archive エンジンは例外であり、インデックスをまったくサポートをしています。

B木の一般的な考え方はすべての値が順番に格納され、各リーグページがルートから等距離にある。
下記の図が表したのもになる。

![Alt text](image/B-tree.png)

上記の図には記載がないがB木インデックスはルートノードからから始まる。
ルートノードの各スロットには子ノードへのポインタが格納され、ストレージエンジンはポインタをたどる。
ストレージエンジンは正しいポインタを特定するために子ノードの値の上限と下限を定義をしており、ストレージエンジンはその上限、下限を見てポインタを判断していって目的のデータを取得する。
リーフページは、他のページへのポインタではなくインデックス付けされた実際のデータへのポインタを保持をしている。

B木構造の利点はデータを検出するのにテーブル全体をスキャンする必要がたいため、データアクセスを高速化すること。

***B木インデックスを使用できるクエリの種類***

B 木インデックスは下記のクエリの場合使用ができる。
クエリの例では「last_name, first_name」の順でインデックスをつけている場合を想定。
- すべての値の一致
    - `SELECT * FROM user WHERE last_name = 'kobayashi' AND first_name = 'taro'`
- 左端のプレフィックスの一致
    - このインデックスは、`kobayashi` という姓を持つ人物を全員検索するのに役立つ。
    - `SELECT * FROM user WHERE last_name = 'kobayashi'`
- 列のプレフィックスの一致
    - 列の値の最初の部分でマッチングを行うことができる。
    - `SELECT * FROM user WHERE last_name LIKE 'k%'`
- 値の範囲の一致
    - このインデックスは、`a` と `d` の間の姓を持つ人物を検索するのに役立つ。
    - `SELECT * FROM user WHERE last_name BETWEEN 'a' AND 'd'`
- ある部分での完全な一致と別の部分での範囲の一致
    - 姓が `kobayashi` 、名が `a`の文字で始まる人物を検索するのに役立つ。
    - `SELECT * FROM user WHERE last_name = 'kobayashi' AND first_name = 'a'`
- インデックス専用クエリ
    - カバリングインデックスのみを使用したクエリ。（詳細は5.3.6で説明）簡単に言うとindex以外取得項目含め使用していないクエリ
    - `SELECT last_name FROM user WHERE last_name = 'kobayashi'` 

B木インデックスは値が順番に並んで保持をしているため、検索とソートの両方に使用ができる。

***B木インデックスの制限**
B木インデックスには制限がある。
クエリの例では「last_name, first_name」の順でインデックスをつけている場合を想定。

- 条件を指定するときにインデックスを付けた順でカラムの指定をしないと効果がない。
    - `SELECT * FROM user WHERE first_name = 'taro' AND last_name = 'kobayashi'`
- インデックスで列をスキップすることはできない。
    - `SELECT * FROM user WHERE first_name = 'taro' AND birthday = '1994-04-23'`
- ストレージエンジンは、最初の範囲条件の右側に位置する列を使ってアクセスを最適化できない。
    - `SELECT * FROM user WHERE last_name = 'kobayashi' AND first_name LIKE 't%' AND birthday = '1994-04-23'`

これらの制限はすべて列の順序付けに関連している。
そのため、パフォーマンスを最適化する際には、クエリを満たすために順序を気にしながらインデックスの作成が必要。

### ハッシュインデックス

ハッシュインデックスは、ハッシュテーブルに基づくインデックスであり、インデックスのすべ
ての列を使用する完全なルックアップでのみ役立つ 。


### 空間（R 木）インデックス

MyISAM で使用ができるインデックス。

###　全文インデックス

テキスト（FULLTEXT）に含まれているキーワードを検索する、特殊なインデックス。

# 5.2 インデックスの利点

インデックスの利点は下記３点ある。

- サーバーが調べなければならないデータの量が少なくなる
- サーバー上でのソートや一時テーブルが不要になる
- ランダム I/O がシーケンシャル I/O に変わる

- データの取得の高速化
    - ノードの上限下限を見て移動をするため目的の位置に素早く移動ができる
- ソートの高速化
    - インデックスではすでにソートされているため、ソートが不要
- グルーピングの高速化
    - 関連する値が近くまとめて格納をしているためグルーピングが高速

データがすでにソートされているため、B 木インデックスは関連する値を近くにまとめて格納する。さらに、B 木インデックスは実際には値のコピーを格納するため、クエリによってはインデックスだけで対応できる。

# 5.3 ハイパフォーマンスを可能にするインデックス戦略

ここでは、インデックスを使用してハイパフォーマンスを可能にする方法を紹介します。

## 5.3.1 列の分離

クエリにおいてインデックス付けされた列が分離されていない場合、インデックスを使用できない。

列の「分離」とは、その列が式の一部であってはならないことまたは、関数に含まれていてはならないことを意味します。


下記例では`actor_id`にインデックスが付与されています。
***式の一部になっている例***

``` sql 
mysql> SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

***関数に含まれている例***
``` sql
mysql> SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;
```

## 5.3.2 プレフィックスインデックスとインデックスの選択性

場合によっては非常に長い文字列にインデックスを付けなければならないことがあります。
長い文字列にインデックスを付与をしてもサイズが大きく、速度も遅くななってしまいます。

そういった場合にプレフィックスインデックスを使用して、最初の数文字をインデックスとすることでサイズの減少ができ速度の向上ができます。

プレフィックスインデックスでは選択性に気をつける必要があります。
例えば最初の1文字をインデックスにした場合、同じ文字から始まるカラムが多いほどインデックスでほしいデータの文字を絞ったあとに目的のデータと合致しているものがどれかを選択しなければ行けないです。そういった状態を選択性が低いということになります。
選択性が高ければインデックスで除外する行の数が多くなる。


例として、カラム`city`にインデックスを付与する場合を考える。
※正規化は考慮していないです。

```
-- テーブル作成
CREATE TABLE sakila.city_demo(city VARCHAR(50) NOT NULL);
-- データ登録
INSERT INTO sakila.city_demo(city) SELECT city FROM sakila.city;
-- 次のステートメントを 5 回繰り返す
INSERT INTO sakila.city_demo(city) SELECT city FROM sakila.city_demo;
-- 分布をランダム化する（効率性よりも利便性を重視）
UPDATE sakila.city_demo　SET city = (SELECT city FROM sakila.city ORDER BY RAND() LIMIT 1);

mysql> SELECT COUNT(*) AS cnt, city
    -> FROM sakila.city_demo GROUP BY city ORDER BY cnt DESC LIMIT 10;

+-----+----------------+
| cnt | city           |
+-----+----------------+
| 65 | London          |
| 49 | Hiroshima       |
| 48 | Teboksary       |
| 48 | Pak Kret        |
| 48 | Yaound          |
| 47 | Tel Aviv-Jaffa  |
| 47 | Shimoga         |
| 45 | Cabuyao         |
| 45 | Callao          |
| 45 | Bislig          |
+-----+----------------+
```

最初の３文字にプレフィックスをする場合を考えて見る。
```
mysql> SELECT COUNT(*) AS cnt, LEFT(city, 3) AS pref
-> FROM sakila.city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;

+-----+------+
| cnt | pref |
+-----+------+
| 483 | San  |
| 195 | Cha  |
| 177 | Tan  |
| 167 | Sou  |
| 163 | al-  |
| 163 | Sal  |
| 146 | Shi  |
| 136 | Hal  |
| 130 | Val  |
| 129 | Bat  |
+-----+------+

```
３文字の場合、各プレフィックスの出現回数のほうがはるかに多くなっている。


プレフィックスの選択性が完全な長さの列とほぼ同じになるまで、プレフィックスを徐々に長くしていく。
今回の場合は7が適切の値です。

```
mysql> SELECT COUNT(*) AS cnt, LEFT(city, 7) AS pref
-> FROM sakila.city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;

+-----+---------+
| cnt | pref    |
+-----+---------+
| 70 | Santiag  |
| 68 | San Fel  |
| 65 | London   |
| 61 | Valle d  |
| 49 | Hiroshi  |
| 48 | Teboksa  |
| 48 | Pak Kre  |
| 48 | Yaound   |
| 47 | Tel Avi  |
| 47 | Shimoga  |
+-----+---------+

-- インデックス作成
alter table city_demo add index name_index(city(7));

```

プレフィックスインデックスでは常にインデックスのサイズと選択性を考慮する必要があります。

# 5.3.3 複数列のインデックス

MySQL 5.0 以降のバージョンでインデックスマージと呼ばれる戦略に従い、うまくインデックス付けされていないテーブルに少しだけ対処できます。

目的の行を見つけ出すために、１つのテーブル内の複数のインデックスをある程度使用ができる。

下記のクエリの場合、5.0以前はテーブルスキャンを行っていた。
``` sql
mysql> SELECT ﬁlm_id, actor_id FROM sakila.ﬁlm_actor WHERE actor_id = 1 OR ﬁlm_id = 1;
```

テーブルスキャンをしないように`UNION`を使用していた。

```sql
mysql> SELECT ﬁlm_id, actor_id FROM sakila.ﬁlm_actor WHERE actor_id = 1 UNION ALL SELECT ﬁlm_id, actor_id FROM sakila.ﬁlm_actor WHERE ﬁlm_id = 1 AND actor_id <> 1;
```

上記に対し5.0以降では両方のインデックスを使用ができ、同時にスキャンをして結果をマージできるようになった。
Extra 列を調べてみるとわかるように、2 つのインデックススキャンの和集合を使用している。

```
mysql> EXPLAIN SELECT film_id, actor_id FROM sakila.film_actor WHERE actor_id = 1 OR film_id = 1\G
*************************** 1. row ***************************
id: 1
select_type: SIMPLE
table: film_actor
type: index_merge
possible_keys: PRIMARY,idx_fk_film_id
key: PRIMARY,idx_fk_film_id
key_len: 2,2
ref: NULL
rows: 29
Extra: Using union(PRIMARY,idx_fk_film_id); Using where

```

複数列のインデックスは、OR 条件の和集合、AND 条件の積集合、2 つの組み合わせの積集合の和集合という 3 種類で使用ができる。

上記の方法でうまくはいくが、下記３つの理由により大抵はテーブルがうまくインデックス付けされていないことのほうが多い。

- 通常は AND 条件でインデックスの積集合を取得する場合、通常は、複数のインデックスの組み合わせではなく、関連する列がすべて含まれた単一のインデックスが必要であることを意味する
- 通常は OR 条件でンデックスの和集合を取得する場合、アルゴリズムのバッファリング、ソート、マージ操作で CPU やメモリリソースが大量に消費されることがある。そのためOR条件はなるべく避けたほうが良い
- UNION自体がコストが高いため、通常のテーブルスキャンよりも実際には遅い可能性がある。

# 5.3.4 適切な列の順序を選択する

インデックスで指定する列の順序はクエリによって決まる。
そのため、クエリに役立つ方法で行がソートされ、グループ化されるような順序を選択する方法について考える必要があります。

列の順序を選択するためには、まずはソートやグループ化をするカラム、次に条件式で使用されるカラムの中で最も選択的な列を先にすること。


