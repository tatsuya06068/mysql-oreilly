# 5章 インデックスによるパフォーマンスの向上

インデックスは、ストレージエンジンが行を素早く検索するために使用するデータ構造のこと。
インデックスはパフォーマンスを向上させるのに欠かせない存在となる。
データセットが大きいほどインデックスの効果は大きくなる。


- 5.1 インデックスの基礎
- 5.2 インデックスの利点
- 5.3 ハイパフォーマンスを可能にするインデックス戦略
- 5.4 インデックスのケーススタディ
- 5.5 インデックスとテーブルの管理
- 5.6 まとめ


# 5.1インデックスの基礎
インデックスは本の索引に置き換えるとわかりやすい。
特定の項目が本のどこに乗っているのかを確認するために索引を調べれば、その項目登場するベージ番号がわかる。

MySQL のストレージエンジンでも、インデックスが同じような方法で使用されている。
下記のクエリを例にした場合、で考える。
```
mysql> SELECT ﬁrst_name FROM sakila.actor WHERE actor_id = 5;
```
`actor_id`列にインデックスを振られている場合、Mysqlでは`actor_id`5の箇所をインデックスを見て検索して行の取得をする。

```
actor_id
1 ・・・ 5行目
2 ・・・ 8行目
3 ・・・ 3行目
4 ・・・ 10行目
5 ・・・ 40行目
```

インデックスには一つだけではなく複数の指定ができる。(例：IDとNameにインデックスを付与)

## 5.1.1 インデックスの種類

インデックスは様々な種類があり、目的に合わせて設計されている。
インデックスはサーバー層ではなくストレージエンジン層で実装されているため、データベースエンジンごとに動作がことなります。

MySQLがサポートしているインデックスの種類について説明します。
※B木インデックスが基本的に使用されるため他のインデックスは簡単な説明にします。

### B木インデックス

インデックスと言われたら基本的にはB木インデックスのことを指しています。

MySQLのストレージエンジンのほとんどは、この種類のインデックスをサポートしている。Archive エンジンは例外であり、インデックスをまったくサポートをしています。

B木の一般的な考え方はすべての値が順番に格納され、各リーグページがルートから等距離にある。
下記の図が表したのもになる。

![Alt text](image/B-tree.png)

上記の図には記載がないがB木インデックスはルートノードからから始まる。
ルートノードの各スロットには子ノードへのポインタが格納され、ストレージエンジンはポインタをたどる。
ストレージエンジンは正しいポインタを特定するために子ノードの値の上限と下限を定義をしており、ストレージエンジンはその上限、下限を見てポインタを判断していって目的のデータを取得する。
リーフページは、他のページへのポインタではなくインデックス付けされた実際のデータへのポインタを保持をしている。

B木構造の利点はデータを検出するのにテーブル全体をスキャンする必要がたいため、データアクセスを高速化すること。

***B木インデックスを使用できるクエリの種類***

B 木インデックスは下記のクエリの場合使用ができる。
クエリの例では「last_name, first_name」の順でインデックスをつけている場合を想定。
- すべての値の一致
    - `SELECT * FROM user WHERE last_name = 'kobayashi' AND first_name = 'taro'`
- 左端のプレフィックスの一致
    - このインデックスは、`kobayashi` という姓を持つ人物を全員検索するのに役立つ。
    - `SELECT * FROM user WHERE last_name = 'kobayashi'`
- 列のプレフィックスの一致
    - 列の値の最初の部分でマッチングを行うことができる。
    - `SELECT * FROM user WHERE last_name LIKE 'k%'`
- 値の範囲の一致
    - このインデックスは、`a` と `d` の間の姓を持つ人物を検索するのに役立つ。
    - `SELECT * FROM user WHERE last_name BETWEEN 'a' AND 'd'`
- ある部分での完全な一致と別の部分での範囲の一致
    - 姓が `kobayashi` 、名が `a`の文字で始まる人物を検索するのに役立つ。
    - `SELECT * FROM user WHERE last_name = 'kobayashi' AND first_name = 'a'`
- インデックス専用クエリ
    - カバリングインデックスのみを使用したクエリ。（詳細は5.3.6で説明）簡単に言うとindex以外取得項目含め使用していないクエリ
    - `SELECT last_name FROM user WHERE last_name = 'kobayashi'` 

B木インデックスは値が順番に並んで保持をしているため、検索とソートの両方に使用ができる。

***B木インデックスの制限**
B木インデックスには制限がある。
クエリの例では「last_name, first_name」の順でインデックスをつけている場合を想定。

- 条件を指定するときにインデックスを付けた順でカラムの指定をしないと効果がない。
    - `SELECT * FROM user WHERE first_name = 'taro' AND last_name = 'kobayashi'`
- インデックスで列をスキップすることはできない。
    - `SELECT * FROM user WHERE first_name = 'taro' AND birthday = '1994-04-23'`
- ストレージエンジンは、最初の範囲条件の右側に位置する列を使ってアクセスを最適化できない。
    - `SELECT * FROM user WHERE last_name = 'kobayashi' AND first_name LIKE 't%' AND birthday = '1994-04-23'`

これらの制限はすべて列の順序付けに関連している。
そのため、パフォーマンスを最適化する際には、クエリを満たすために順序を気にしながらインデックスの作成が必要。

### ハッシュインデックス

ハッシュインデックスは、ハッシュテーブルに基づくインデックスであり、インデックスのすべ
ての列を使用する完全なルックアップでのみ役立つ 。


### 空間（R 木）インデックス

MyISAM で使用ができるインデックス。

###　全文インデックス

テキスト（FULLTEXT）に含まれているキーワードを検索する、特殊なインデックス。

# 5.2 インデックスの利点





