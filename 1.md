# 1章MySQLのアーキテクチャと歴史

### MySQLについて
MySQLはアーキテクチャに特徴があるため、最大限にMySQLを活かすにはアーキテクチャを理解し、逆らうことなく足並みを揃える必要があります。
> アーキテクチャとは抽象的、基本的な構造や設計、動作原理、実現方式などを表す言葉

MySQLのアーキテクチャとなる部分はクエリの処理やその他のサーバータスクをデータの格納と取得から分離するように設計された、ストレージエンジンアーキテクチャになります。
この関心の分離によりデータを格納する方法と、必要なパフォーマンスや機能、その他の特性を選択することができます。
本章では、サーバーアーキテクチャの理解を深めます。

# 1.1MySQLの論理アーキテクチャ

下記の図はMySQLのアーキテクチャを論理的に表した図です。
<br>

![image1](/image/image1.jpg)

- 1つ目のレイヤ（クライアント、接続・スレッド処理）
  - 接続の処理、認証、セキュリティなど、ネットワークベースのほとんとどのクライアント/サーバーツールで必要となるサービス
- ２つ目のレイヤ（パーサー、クエリキャッシュ）
  - クエリ解析、分析、最適化、キャッシュ、及びすべての組み込み関数（日付、時間等）のコードが含まれる。
  ストアドプロシージャ、トリガ、ビューなど、ストレージエンジン全体で提供される機能は全て、このレベルに属している。
> ストアドプロシージャとは、データベースに対する一連の処理手続きを1つのプログラムにまとめ、リレーショナル・データベース管理システム）に保存したものです
- 3つ目のレイヤ（ストレージエンジン）
  - MySQLの中に格納される全てのデータの保存と取得を受け持つ。<br>ストレージエンジンAPIを通じて、やり取りをすることで、ストレージエンジン間の違いを吸収して、クエリレイヤではエンジンが違いを気にする必要がない。また、ストレージエンジンAPIにはトランザクションの開始や主キーを持つ行を取得といった操作を実行する低レベルの関数が多数含まれています。ストレージエンジンはSQLの解析、相互に通信することもなく、サーバからのリクエストに応答するだけです。

## 1.1.1 接続の管理とセキュリティ

クライアント接続はそれぞれサーバープロセス内で独自のスレッドを取得する。接続のクエリはその１つのスレッドで実行され、そのスレッドは１つのコアまたはCPUに関連付けれる。
<br>
サーバーはスレッドをキャッシュするため、新しい接続のたびにスレッドの作成と削除を繰り返さない。
<br>
クライアントがMySQLサーバーに接続する際には、サーバーがそれらを認証（ユーザー名、接続元ホスト、パスワード）を行う。認証後、サーバーはクライアントが特定のテーブルにアクセスする権限を持っているか確認をする。

## 1.1.2 最適化と実行

MySQLはクエリを解析して内部構造（解析ツリー）を作成したあと、様々な最適化を適用する。最適化には、クエリの書き換え、テーブルを読み取る順序の決定、使用するインデックスの選択などが含まれる。
<br>
最適化の様々な側面についてサーバーに説明を求めることができ、サーバーがどのような決断を下すのか明らかになることでクエリ、スキーマ、設定を見直して、効率化をするための基準点が得られる。
（詳しくは６章で説明）
<br>
オプティマイザはストレージエンジンの機能、特定の操作にかかるコスト、テーブルデータの統計をストレージエンジンに問い合わせる。例えば1部のストレージエンジンは特定のクエリに役立つタイプのインデックスをサポートしている。（インデックスの作成とスキーマの最適化については４章、５章で説明）
<br>
サーバーはクエリを解析する前であってもSELECT文とそれらの結果セットだけが格納されるクエリキャッシュを調べる。キャッシュにあった場合、解析、最適化、実行を行わずキャッシュに格納されている結果セットだけを返す。（7章で説明）

# 1.2 並行性の制御
MySQLはサーバーレベルとストレージエンジンレベルの２つのレベルで、並行性の制御を行っている。
大まかにリーダーとライターにどのように対処をしているのかを説明。

## 1.2.1 読み取り/書き込みロック

ロックが必要な理由として、1つのテーブルを読み取っている間に書き込みが同時に行うとタイミングによっては矛盾したデータをクライアントへ返してしまうかもしれないです。
解決する方法として同時読み取り、書き込みアクセス対処する方法は下記の２種類ある。
* 共有ロック(読み取りロック)
    * 複数のクライアントがリソースを同時に読み取り互いに干渉しない
* 排他ロック（書き込みロック）
    * 書き込みを行えるクライアントは常に1つだけにする。書き込み中は全ての読み取りも阻止する。

## 1.2.2 ロックの粒度
共有リソースの並行性を向上させる方法の1つは何をロックするかが重要である。
<br>
ロックをするにはリソースをロックの取得、ロックが空いているかどうかのチェック、ロックの解除を含めどのロック操作にもオーバーヘッドが伴う。そのため、システムがロックの管理に時間を取られ過ぎてしまえば、パフォーマンスの低下する恐れがある。
<br>
ロックではオーバーヘッドとデータの安全性にどのように折り合いをつけるかがパフォーマンスを左右する。
<br>
ロックは書き込みを読み取りより優先して行うため、キューに読み込みがあっても書き込みをキューの前方へ配置する。
<br>
下記２つが最もなロックに使用される。
* テーブルロック
    * MySQLで基本的で最もオーバーヘッドが低いロックである。ストレージエンジンで実装されており。テーブル全体をロックする。
* 行ロック
    * 並行性が最も高いがオーバーヘッドが高いロックである。ストレージエンジンで実装されて折、行単位でロックする。

# 1.3 トランザクション
トランザクションとは１つの作業単位としてアトミックに扱われるSQLクエリの集まりのこと。データベースエンジンはクエリ全体をデータベースに適用するか、全て適用されないかのどちらかを行う。
<br>
トランザクションが適切なのかは **ACIDテスト**にパスしていれば良い。
### ACIDトランザクション
- 原子性（atomicity）
    - トランザクション全体が適用されるかロールバックされるようにするには、トランザクショ
ン全体が 1 つの分割できない作業単位として機能しなければならない。トランザクション
がアトミックである場合、部分的に完了するトランザクションのようなものは存在しない。
すべてが完了するか、まったく完了しないかのどちらかである。

- 一貫性（consistency）
    - いかなる場合もデータベースは 1 つの一貫した状態から次の一貫した状態へ遷移すべきで
ある。例として銀行のシステムの場合システムがクラッシュしたとしても、一貫性によ
り、引き落としに失敗したとしても口座の金額は減ったりしない。このトランザクションがコミットされるこ
とはないため、トランザクションの変更は 1 つもデータベースに反映されない。

- 分離性（isolation）
    - 通常、トランザクションの結果はトランザクションが完了するまで他のトランザクション
からは見えない。このため、銀行のシステムで置き換えた場合、引き落とし中に銀行口座の明細書を作成しても、当座預金口座には引き落とし前の金額が含まれたままである。

- 永続性（isolation）
    - コミットされたトランザクションの変更は確定される。つまり、システムがクラッシュした
としてもデータが失われないよう、変更は記録しなければならない。ただし、実際には多く
のレベルに分かれていることから、永続性はややあいまいな概念である。他よりも高い安全
性を保証する永続化戦略もあるが、100 パーセントの永続性というものは存在しない（仮に、
データベース自体に完全な永続性があるとしたら、バックアップでどのようにして永続性
を高めるというのか）。MySQL において永続性が実際に何を意味するかについては、別の
章で説明する。

## 1.3.1
SQL 規格は 4 つの分離レベルを定義しており、
トランザクショ
ンの内外で見える変更と見えない変更に関するルールを定めている。一般に、分離レベルが低いほ
ど並行性が高くなり、オーバーヘッドが低くなる。
<br>
MySQLは **REPEATABLE READ**がデフォルトのトランザクション分離レベルである。

- READ UNCOMMITTED
    - この分離レベルでは、コミットされていないトランザクションの結果が他のトランザクショ
ンから見える。自分が何をしているのかを十分に理解していて、そうする十分な理由がある
ならともかく、この分離レベルはいろいろな問題をはらんでいる。さまざまな利点を持つ他
の分離レベルと比べて特にパフォーマンスがよいわけではないため、実際に使用されるこ
とは滅多にない。コミットされていないデータを読み取ることはダーティリードとも呼ば
れる。

- READ COMMITTED
    - ほとんどのデータベースシステム（ただし MySQL を除く）のデフォルトの分離レベルは
READ COMMITTED である。この分離レベルは、先の分離レベルの単純な定義を満たしてい
る。つまり、トランザクションから見えるのは、それが開始されたときにすでにコミットさ
れていたトランザクションによる変更だけで、その変更はコミットするまで他のトランザ
クションからは見えない。この分離レベルでは、ノンリピータブルリードと呼ばれるものが
許可される。ノンリピータブルリードは、同じステートメントを 2 回実行すると異なるデー
タが返される可能性があることを意味する。

- REPEATABLE READ
    - この分離レベルは、READ UNCOMMITTED が放置している問題を解決する。この分離レベル
では、トランザクションが読み取るすべての行が、同じトランザクション内で
読み取りで「同じに見える」ことが保証されるが、理論的には、ファントムリードと呼ばれ
る別のやっかいな問題が放置されたままとなる。簡単に言うと、ファントムリードとは、あ
る範囲の行を選択した後、別のトランザクションがその範囲に新しい行を挿入し、その後に
同じ範囲を再び選択したときに、新しいファントム（幻の）行が現れるという問題である。
InnoDB と XtraDB は、MVCC（MultiVersion Concurrency Control）に基づいて、ファント
ムリードの問題を解決する。

- SERIALIZABLE
    - 最も高いレベルの分離性であり、競合が起こらないようにトランザクションを強制的に順
序付けて、ファントムリードの問題を解決する。要するに、この分離レベルは読み取るすべ
ての行にロックを設定する。この分離レベルでは、タイムアウトやロック競合が頻発する可
能性がある。この分離レベルが使用されることは滅多にないが、アプリケーションのニーズ
によっては、データの安定性を優先して並行性の低下を受け入れざるを得ないことがある。

## 1.3.2
**デッドロック**とは複数のトランザクションが同じリソースのロックをめぐって競合し、それぞ
れロックをリクエストして依存関係の循環を招くことである。デッドロックが発生するのは、トラ
ンザクションが異なる順序でリソースをロックしようとしたときであり、複数のトランザクション
が同じリソースをロックするたびに発生する可能性がある。

> 例 
<br>
トランザクション #1
<br>
START TRANSACTION;
<br>
UPDATE StockPrice SET close = 45.50 WHERE stock_id = 4 and date = '2002-05-01';
<br>
UPDATE StockPrice SET close = 19.80 WHERE stock_id = 3 and date = '2002-05-02';
<br>
COMMIT;
<br>
<br>
トランザクション #2
<br>
START TRANSACTION;
<br>
UPDATE StockPrice SET high = 20.12 WHERE stock_id = 3 and date = '2002-05-02';
<br>
UPDATE StockPrice SET high = 47.20 WHERE stock_id = 4 and date = '2002-05-01';
<br>
COMMIT;
<br>
<br>
運が悪ければ、トランザクションがそれぞれ 1 つ目のクエリを実行してデータ行を更新し、その
過程でその行をロックする。次に、トランザクションがそれぞれ 2 つ目のクエリを実行し、その行
がすでにロックされていることに気づく。何かが割り込んできてデッドロックを解消するまで、2
つのトランザクションは相手が完了するのを永遠に待つことになる。

データベースシステムはさまざまな形式のデッドロック検出とタイ
ムアウトを実装している。InnoDB ストレージエンジンなどの高度なシステムは、循環依存を検出
するとすぐにエラーを返す。

## 1.3.3 トランザクションログ
 トランザクションログはトランザクションの効率化に役立つ。
 <br>
 ストレージエンジンは、変更が発生するたびにディスク上のテーブルを更新するのでなく、データのメモリ上のコピーを変更する。
<br>
その後、ストレージエンジンは変更の記録をトランザクション
ログに書き込むことができる。トランザクションログはディスク上にあるため、
永続性がる。
<br>
その後でタイミングを見計らって、ディスク上のテーブルを更新できる。したがって、このログの先行書き込みと呼ばれる手法を用いているほとんどのストレージエンジンは、変更をディスクに 2 回書き込むことになる。
更新がトランザクションログに書き込まれてからデータ自体が変更されるまでの間にクラッシュ
が発生したとしても、ストレージエンジンは再起動時に変更を取り戻すことができる。リカバリの
方法はストレージエンジンによって異なる。

## 1.3.4 MySQLのトランザクション
MySQL は、InnoDB と NDB Cluster の 2 つのトランザクショナルストレージエンジンを提供し
ている。

### AUTOCOMMIT
MySQL は、デフォルトでは AUTOCOMMIT モードで動作する。つまり、トランザクションを明
示的に開始しない限り、クエリはそれぞれ別々のトランザクションで実行される。

### トランザクションでの複数のストレージエンジンの併用
MySQL はトランザクションをサーバーレベルで管理しない。
<br>
トランザクションを実装するのは
ストレージエンジンである。これは、複数のエンジンを 1 つのトランザクションで併用することが
不可能であることを意味する。
<br>
トランザクショナルテーブルと非トランザクショナルテーブル（たとえば InnoDB テーブルと
MyISAM テーブル）がトランザクションに含まれている場合は、順当にいけば、トランザクション
は正常に処理されるだろう。
だが、ロールバックが要求された場合、非トランザクショナルテーブルへの変更を取り消すこと
はできないため、データベースは矛盾した状態に陥ってしまう。そこからの回復は難しいか
もしれないため、トランザクションの意義そのものがあやうくなる。
テーブルごとに正しいストレージエンジンを選択することがきわめて重要なのは、このためである。

# マルチバージョンの並行性制御（MVCC）
MySQL のトランザクショナルストレージエンジンのほとんどは、単純な行ロックメカニズムを
使用しない。代わりに、行レベルのロックと MVCC（MultiVersion Concurrency Control）と呼ばれ
る並行性を高める手法を組み合わせて使用する。

# 1.5 MySQLのストレージエンジン
MySQL は、各データベースをそのデータディレクトリのサブディレクトリとしてファイルシ
ステムに格納する。これらのデータベースはスキーマとも呼ばれている。
<br>
テーブルを作成する際、
MySQL はテーブルと同じ名前の .frm 拡張子が付いたファイルにテーブルの定義を保存する。
<br>
ーブルに関する情報を表示するには、`SHOW TABLE STATUS` コマンドを使用する。MySQL 5.0
以降は、`INFORMATION_SCHEMA` のテーブルに問い合わせることもできる。

## 1.5.1 InnoDBエンジン
nnoDB は、MySQL のデフォルトのトランザクショナルストレージエンジンであり、最も重要で
あると同時に、総合的に見て、広く役立つストレージエンジン。
<br>
通常はロールバックされずに完了するさまざまな短命のトランザクションの処理を前提に設計され
ている。
<br>
パフォーマンスがよく、自動クラッシュリカバリ機能を備えていることから、非トランザ
クショナルストレージが必要な場合にもよく使用されている。
<br>
どうしても他のエンジンを使用する必要がある場合を除いて、テーブルには InnoDB を使用すべきである。
<br>
また、ストレージエンジンについて調べたい場合は、すべてのストレージエンジンを万遍なく調べるよりも、InnoDB についてできるだけ詳しくなるために時間をかける価値が十分にある。

### InnoDBの概要
テーブル領域と総称される 1 つ以上のデータファイルにデータを保存する。
<br>
InnoDB はテーブル単位でデータとインデックスを別のファイルに保存できる。
<br>
InnoDB の振る舞いはかなり複雑なので、InnoDB を使用する場合は、ぜひ MySQL マニュアルの
***[InnoDB トランザクションモデルとロック](https://dev.mysql.com/doc/refman/5.6/ja/innodb-transaction-model.html)***セクションを読む。
<br>
InnoDB は MVCC アーキテクチャに基づいているため、InnoDB を使ってアプリケーションを作成する前に知っておきたい詳細な情報が含まれている。
<br>

## 1.5.2 MyISAMエンジン
全文インデックス、圧縮、空間（GIS）関数など、さまざまな機能をサポートしている。
<br>
トランザクションまたは行レベルのロックをサポートしていない。

## 1.5.3 MySQL のその他の組み込みエンジン

- Archive エンジン
- Blackhole エンジン
- CSV エンジン
- Federated エンジン
- Memory エンジン
- Merge エンジン
- NDB Cluster エンジン
