# MySQLのベンチマーク
ベンチマークとはシステムにストレスをかけるように設計されたワークロードのこと。
>ここで言っているワークロードとは処理の負荷の大きさのこと
ベンチマークを実行することで、どれだけの負荷に耐えられるのかを知ることができる。
本書ではMySQLのベンチマークを実行するのに最適なツールである「SysBench」を元に説明をしています。

# 2.1ベンチマークを実行する理由
負荷がかかっているときのシステムの振る舞いを観察しながら、キャパシティの特定し、どの変更が重要なのかを様々なデータを使って性能を調べることができる。
ベンチマークでは、以下のことができる。
- システムに関する想定を検証し、それらの想定が現実的かどうかを確認する。
- 解決しようとしているシステムの不正な動作を再現する。
- アプリケーションの現在のパフォーマンスを計測する。
- 実際の稼働環境のシステムが対応できる以上の負荷をシミュレートし、システムが成長した
ときに最初に遭遇するであろうスケーラビリティのボトルネックを特定する。
- 成長を予測する。アップグレードやアプリケーションの大きな変更の際にリスクを軽減するのに役立つ。
- アプリケーションが環境の変化に対応できるかどうかをテストする。
- さまざまなハードウェア、ソフトウェア、オペレーティングシステム設定をテストする。
- 購入したばかりのハードウェアが正しく設定されていることを検証する。

ベンチマークはできる限り高速に実行され、システムの正常な動作に支障をきたすほど負荷をかけることが作成するにあたり重要となる。
ベンチマークのテストをする際には自分が何をしているのか、結果がどのように有意義なのかを自覚

#  2.2ベンチマークの戦略
戦略には主に２種類に分かれる。
- フルスタックベンチマーク
    - アプリケーション全体のベンチマークを実行
- 単一コンポーネントベンチマーク
    - MySQLを分離する

***フルスタックベンチマークの利点***
- Webサーバー、アプリケーション、DB等含め全体のテストをすることで、アプリケーション全体としてどうであるか調べられる。
- MySQLが常にボトルネックとは限らないため、全てテストをして調べることができる。
- 各部分のキャッシュの振る舞いを調べるには、全体のテストが必要
- ベンチマークが意味を持つのは、実際のアプリケーションの振る舞いが反映される範囲までである。アプリケーションの一部しかテストしていない場合、ベンチマークに意味を持たせるのは難しい。

***単一コンポーネントの利点***
- 様々なスキーマやクエリを比較したい。
- アプリケーションで確認された特定の問題をベンチマークしたい。
- 短いベンチマークを使って変更と計測の「サイクル時間」を短くしたい。

テストをする際には、できるだけ現実的なものを使用する。可能であれば実際のデータのスナップショットの使用が良い。

## 2.2.1 何を計測するか
以下の計測項目と、それらが目標とどのように適合するのか考える。
- スループット
    - スループットは、時間単位あたりのトランザクションの数として定義されている。1秒あたりのトランザクションの数を計測する。
- 応答時間または遅延
    - タスクに必要な合計時間を計測する。
- 並行性
    - 実際の並行並行性のテストを行いピーク時の負荷に対象できるか計測をする。同時に作業を行うスレッドや接続の数を計測をしてスループットが低下したり、応答時間が長くなったりしないかどうかを計測をする。
- スケーラビリティ
    - タスクを完了しようとするワーカーの数を２倍にした場合に、作業量が２倍になるかテストを行う。

# 2.3ベンチマークの戦術
ベンチマークを設計して実行する方法について説明をするが、先に一般的な間違いを先に述べていく。
- 数百ギガバイトのデータを処理しなければならないアプリケーションで１ギガバイトのデータしか使用しない。
- 稼働中のシステムのデータに「ホットスポット」があるにも関わらず均等に分散されたデータを使用している。
- 全てのユーザープロファイルが均等に参照されるように見せかけるなど、非現実的に分散させたパラメータを使用している。
- マルチユーザーアプリケーションに対してシングルユーザーのシナリオを使用している。
- 1 台のサーバー上で分散アプリケーションのベンチマークを実行している。
- Web ページ上での「思考時間」などが現実のユーザーの振る舞いと一致していない。
- ループを使ってまったく同じクエリを実行すること。現実のクエリはまったく同じではない
ため、キャッシュミスを引き起こす。
- エラーのチェックを怠っている。
- リブートの直後であるなど、システムのウォームアップが完了していないときのパフォーマ
ンスを無視している。
- デフォルトのサーバー設定を使用している
- ベンチマークの時間が短すぎる。ベンチマークはしばらく実行し続ける必要がある。

通常はテストができるだけ現実的なものになるよう努力すべきである。

## 2.3.1 ベンチマークの設計と計画
ベンチマークを計画するためには、問題と目標の洗い出しが必要。次に標準のベンチマークを使用するのか、独自に設計するのかを決定する。
標準のベンチマークを使用する場合は、ニーズに適合するものを選択しなければならない。
カスタムベンチマークの設計は、複雑で繰り返しの多いプロセスである。

***カスタムベンチマーク作成手順***
1. 繰り返し利用できるように実際の稼働環境のデータセットのスナップショットを作成する。
1. ピーク時やまる一日といった代償的な時間枠で、実際の稼働環境のシステム上で実行されるクエリを全て記録する。

## 2.3.2 ベンチマークを実行する時間の長さ
ベンチマークに意味を持たせるためには、その実行時間が十分な長さである必要がある。基本的にはシステムの定常状態のパフォーマンスを知りたいはずのため、ベンチマークを実行しておいて定常状態になるのを待つ必要がある。

## 2.3.3 システムのパフォーマンスとステータスを補足する。
ベンチマークを実行する際には、テストの対象となるシステムに関する情報をできるだけ集めることが重要。
ベンチマークを実行するたびに、結果、設定ファイル、計測値、スクリプト、覚書を適切にディレクトリに保存をしておく。

## 2.3.4 正確な結果を取得する
常に正しい結果を得られているのか下記の内容を考える必要がある。
- 正しいベンチマークを選択しているか
- 質問に答えるために必要なデータを取得できているか
- 間違った条件でベンチマークを実行していないか

べンチマークの結果が再現可能であるかを確認する。
- ベンチマークの実行を開始するたびにシステムの初期状態が同じになるようにする。

ウォームアップ済みのサーバーでベンチマークを実行する必要がある場合は（通常はそうである）、ウォームアップの時間が十分で、再現可能であることも確認する。

## 2.3.5 ベンチマークを実行し、結果を分析する
準備ができたらベンチマークを実行して、データの収集と分析に取り掛かる。
できることならベンチマークの実行を自動化するのが良い。実行のたびにうっかり違うことをしてしまったり、手順を忘れてしまったりすることがないため、結果が改善され、それらがより正確なものになる。

自動化の方法はシェルやPHPなど好きなのを使用すれば良い。

通常、ベンチマークは数回に渡って実行をして全ての結果から平均をだす。

## 2.3.6 グラフ化の重要性
システムパフォーマンスの計測値に関して最も効果的なのは、時系列でグラフ化すること。

生のデータをみるよりもグラフ化したほうが問題の発見が行いやすい。

# 2.4ベンチマークツール
ベンチマークシステムは独自に作成せずに既存のベンチマークシステムを使用するのが良い。

ベンチマークにはフルスタックと単一コンポーネントの2種類あるため、それぞれの実行ツールの紹介。
## 2.4.1 フルスタックツール
### ab
Apache HTTPサーバーのベンチマークツール。
Web アプリケーションのベンチマークを実行している場合は、アプリケーション全体が 1 秒間に処理できるリクエストの数を測定できる。
１つのURLをできおるだけすばやくテストすることが目的なので、実用性は限られる。
[ ドキュメント](http://httpd.apache.org/docs/2.0/programs/ab.html)
### http_load
abと似ているがより柔軟に使用できる。
数種類のURLが含まれた入力ファイルを作成でき、そこからURLがランダムに選択される。
単に素早く実行するのではなく、リクエストを指定したレートで実行できる。
 [ドキュメント](http://www.acme.com/software/http_load/)
### JMeter
アプリケーションに負荷をかけ、パフォーマンスを計測できるJavaアプリケーション。
現実のユーザーをより柔軟に趣味レートできる機能がある。結果をグラフ化するためのGUIを備えている。
[ドキュメント](http://jakarta.apache.org/jmeter/)
## 2.4.1 単一コンポーネントツール
### mysqlslap
サーバー上の負荷をシミュレートし、所要時間に関する情報を報告する。
使用する同時接続の数を指定することが可能。
[ドキュメント](http://dev.mysql.com/doc/refman/5.1/en/mysqlslap.html)

### MySQL Benchmark Suite(sql-bench)
MySQL サーバーとともに専用のベンチマークスイートを配布しており、それを使って様々なデータベースサーバーのベンチマークテストを実行できる。
シングルスレッドでサーバーがクエリを実行する速さを測定する。その結果から、サーバ上での実行パフォーマンスが良い操作がどれであるかがわかる。

このベンチマークの主な利点と欠点
- 利点
    - あらかじめ定義された使いやすいテストが多数含まれているため、複数のストレージエンジンや設定をかんたんに比較できる。
- 欠点
    -  シングルユーザーのため複数のCPUの効果を評価できない。
    - 非常に小さなデータセットを使用すること
    - サイト固有のデータをテストできないこと
    - 実行ごとに結果が変化する可能性があること
[ドキュメント](http://dev.mysql.com/doc/refman/5.6/en/mysql-benchmarks.html)

### Super Smack
MySQL と PostgreSQL 用のベンチマーク、ストレステスト、負荷生成ツール。
複数のユーザーをシミュレート、テストデータをデータベースにロード、ランダムに生成されたデータをテーブルに挿入することが可能。
[ドキュメント](http://vegan.net/tony/supersmack/)
### Database Test Suite
一部の業界標準のベンチマークと同様のベンチマークを実行する。

### PerconaのTPCC-MySQLツール
複雑な負荷のかかる状況で MySQL の動作を評価するのによく使用する。
単純なベンチマークには、SysBenchが良いと思う。

### SysBench
ファイルI/O、OSスケジューラ、メモリの割当と転送速度、POSIXスレッド(スレッド・ライブラリのこと)、データベースサーバー自体のパフォーマンスを計測できる。
柔軟にテストできるようにするLua言語でのスクリプティングをサポートしてる。
[ドキュメント](https://github.com/akopytov/sysbench)

***MySQLの便利な関数について***
MySQL には、BENCHMARK() という便利な関数がある。
この関数を利用すれば、特定の種類の操作をテストして、実行速度を確認できる。
```sql
mysql> SET @input := 'hello world';
mysql> SELECT BENCHMARK(1000000, MD5(@input));
+---------------------------------+
| BENCHMARK(1000000, MD5(@input)) |
+---------------------------------+
|
0 |
+---------------------------------+
1 row in set (2.78 sec)
mysql> SELECT BENCHMARK(1000000, SHA1(@input));
+----------------------------------+
| BENCHMARK(1000000, SHA1(@input)) |
+----------------------------------+
|
0 |
+----------------------------------+
戻り値は常に 0 
```
# 2.5ベンチマークの例

## 2.5.1 http_load
urls.txtというファイルにURLを保存しておく。
```txt
http://www.mysqlperformanceblog.com/
http://www.mysqlperformanceblog.com/page/2/
http://www.mysqlperformanceblog.com/mysql-patches/
http://www.mysqlperformanceblog.com/mysql-performance-presentations/
http://www.mysqlperformanceblog.com/2006/09/06/slow-query-log-analyzes-tools/
```
http_load を使用する最も簡単な方法は、URL をループで取り出す（フェッチする）こと。
```
$ http_load -parallel 1 -seconds 10 urls.txt
19 fetches, 1 max parallel, 837929 bytes, in 10.0003 seconds
44101.5 mean bytes/connection
1.89995 fetches/sec, 83790.7 bytes/sec
msecs/connect: 41.6647 mean, 56.156 max, 38.21 min
msecs/first-response: 320.207 mean, 508.958 max, 179.308 min
HTTP response codes:
code 200 - 19
```
結果は、リクエストに関する統計データを示すだけである。
他にも5人の同時ユーザーをシミュレートしたり、負荷をかけるために1秒あたりのリクエスト数を20にして、接続と応答にかかる時間をみることができる。

## 2.5.2 MySQL Benchmark Suite
Perl ベンチマークで構成されているため、実行するのにPerlが必要。
このベンチマークは、MySQLのインストールに含まれている。
Debianでは、/usr/share/mysql/sql-bench/ にある 。
すべてのテストを実行する場合は、次のようなコマンドを使用する。
```
$ cd /usr/share/mysql/sql-bench/
sql-bench$ ./run-all-tests --server=mysql --user=root --log --fast
Test finished. You can find the result in:
output/RUN-mysql_fast-Linux_2.4.18_686_smp_i686
```
実行結果
```
ql-bench$ tail -5 output/select-mysql_fast-Linux_2.4.18_686_smp_i686
Time for count_distinct_group_on_key (1000:6000): 34 wallclock secs ( 0.20 usr 0.08 sys + 0.00 cusr 0.00 csys = 0.28 CPU)
Time for count_distinct_group_on_key_parts (1000:100000): 34 wallclock secs ( 0.57 usr 0.27 sys + 0.00 cusr 0.00 csys = 0.84 CPU)
Time for count_distinct_group (1000:100000): 34 wallclock secs ( 0.59 usr 0.20 sys + 0.00 cusr 0.00 csys = 0.79 CPU)
Time for count_distinct_big (100:1000000): 8wallclock secs ( 4.22 usr 2.20 sys + 0.00 cusr 0.00 csys = 6.42 CPU)
Total time: 868 wallclock secs (33.24 usr 9.55 sys + 0.00 cusr 0.00 csys = 42.79 CPU)
```
count_distinct_group_on_key (1000:6000) はテストの実行に 34 秒かかっているということで、これはクライアントがテストの実行に要した時間の合計。
（usr 、sys 、cursr 、csys）は、このテストのオーバーヘッドに相当しており、クライアントの処理を実行してかかった時間が0.28秒かかっている。
ここで見るべき数字はクライアントの制御がおよばないもので手がふさがっていた時間 の33.72 秒'(テストを実行するまでの時間 - クライアントコードの実行時間)
スイート全体を実行するのではなく、テストを個別に実行することができ、個別に挿入テストや更新テストをしたほうがより詳細な情報が得られる。

## 2.5.3 SysBench
このツールはデータベースのパフォーマンスだけではなく、システムのデータベースサーバーとしてのパフォーマンスもテストできるように設計されている。
SysBench は InnoDB とほぼ同じように動作するため、fileio テストをそのまま実行できる。
本では詳細に書かれているがここでは、紹介されているテストを簡単に記載しておきます。

***SysBenchのCPUベンチマーク***
CPUの性能をテストできる。
```
server1 ~]$ cat /proc/cpuinfo
...
model name : AMD Opteron(tm) Processor 246
stepping : 1
cpu MHz : 1992.857
cache size : 1024 KB
```
上記のスペックのCPUに対してい次のようにしてベンチマークを実行する。
```
[server1 ~]$ sysbench --test=cpu --cpu-max-prime=20000 run
sysbench v0.4.8: multithreaded system evaluation benchmark
...
Test execution summary: total time: 121.7404s
```
 複数のCPUを計測して適切なCPUを選択できる。

***SysBench のファイル I/O ベンチマーク***

fileio ベンチマークは、さまざまな I/O 負荷をかけてシステムのパフォーマンスを計測する。
このテストは、ハードディスク、RAIDカード、 RAIDモードの比較と、I/Oサブシステムの調整に役立つ。


***SysBench の OLTP ベンチマーク***

OLTP ベンチマークは、トランザクション処理のワークロードをエミュレートします。
100万行のテーブルの列を見る場合のテストをする場合、まず、テスト用のテーブルを準備。
```
$ sysbench --test=oltp --oltp-table-size=1000000 --mysql-db=test --mysql-user=root prepare
```
次に、同時スレッドを8つ使ってベンチマークを読み取り専用モードで60秒間実行する。
```
$ sysbench --test=oltp --oltp-table-size=1000000 --mysql-db=test --mysql-user=root --max-time=60 --oltp-read-only=on --max-requests=0 --num-threads=8 run
```
下記の結果が表示される。
```
OLTP test statistics:
queries performed:
read: 179606
write: 0
other: 25658
total: 205264
transactions: 12829 (213.07 per sec.)
deadlocks: 0(0.00 per sec.)
read/write requests:  179606 (2982.92 per sec.)
other operations: 25658 (426.13 per sec.)

Test execution summary:
total time: 60.2114s
total number of events: 12829
total time taken by event execution: 480.2086

per-request statistics:
min: 0.0030s
avg: 0.0374s
max: 1.9106s
approx. 95 percentile:
Threads fairness: 0.1163s
events (avg/stddev): 1603.6250/70.66
execution time (avg/stddev): 60.0261/0.06
```
下記が気にすべき箇所になる。
- トランザクションの数 ・・・12829
- 1 秒あたりのトランザクションの数・・・213.07 per sec.
- リクエストごとの統計値（最低、平均、最大、95 パーセンタイル時間）・・・Latency (ms)
- シミュレートされたワークロードの公平性を示すスレッドの公平性の統計値・・・Threads fairness

***その他の機能***
データベースサーバーのパフォーマンスを直接計測しない、他のシステムベンチマークも実行できる。
- memory
- threads
- mutex
- seqwr 

## 2.5.4 Database Test Suite の dbt2 TPC-C
TPC-C は、TPC によって公開されている仕様であり、複雑な OLTP 負荷をエミュレートし、1 分あたりのトランザクションの数（tpmC）と各トランザクションのコスト（Price/tpmC）を報告する。
*OLTP(オンライントランザクション処理 )
結果はハードウェアに大きく左右される。

## 2.5.5 Percona の TPCC-MySQL ツール
SysBenchよりも現実のアプリケーションが生成するワークロードに近いテストを行うとこがでする。

# 2.6 まとめ
SysBench にまだ慣れていない場合は、少なくとも使い方をマスターしておこう。最低でも、oltp ベンチマークとfileio ベンチマークの使い方を学んでおこう。oltp ベンチマークは、さまざまなシステムをすばやく比較するのに非常に便利である。